// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

/**
 * @dev {ERC1155} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract ERC1155PresetMinterPauserUpgradeableCustom is
	Initializable,
	ContextUpgradeable,
	AccessControlEnumerableUpgradeable,
	ERC1155BurnableUpgradeable,
	ERC1155PausableUpgradeable
{

	bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
	bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
	bytes32 public constant POLYNETWORK_ROLE = keccak256("POLYNETWORK_ROLE");

	/**
	 * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that
	 * deploys the contract.
	 */
	function __ERC1155PresetMinterPauser_init(string memory uri) internal initializer {
		__Context_init_unchained();
		__ERC165_init_unchained();
		__AccessControl_init_unchained();
		__AccessControlEnumerable_init_unchained();
		__ERC1155_init_unchained(uri);
		__ERC1155Burnable_init_unchained();
		__Pausable_init_unchained();
		__ERC1155Pausable_init_unchained();
		__ERC1155PresetMinterPauser_init_unchained();
	}

	function __ERC1155PresetMinterPauser_init_unchained() internal initializer {
		_setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
		_setupRole(MINTER_ROLE, _msgSender());
		_setupRole(PAUSER_ROLE, _msgSender());
		_setupRole(POLYNETWORK_ROLE, _msgSender());
	}

	/**
	 * @dev polynetwork CrossChainNFTMapping
	 */
	function mintWithURI(
		address to,
		uint256 tokenId,
		string memory uri,
		uint256 amount
	) external {
		require(hasRole(POLYNETWORK_ROLE, _msgSender()), "mintWithURI: must have POLYNETWORK_ROLE role to mint");
		_mint(to, tokenId, amount, "");
		_setURI(uri);
	}

	function setURI(string memory uri_) external {
		require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have admin role to set new uri");
		_setURI(uri_);
	}

	/**
	 * @dev Creates `amount` new tokens for `to`, of token type `id`.
	 *
	 * See {ERC1155-_mint}.
	 *
	 * Requirements:
	 *
	 * - the caller must have the `MINTER_ROLE`.
	 */
	function mint(
		address to,
		uint256 id,
		uint256 amount,
		bytes memory data
	) internal virtual {
		_mint(to, id, amount, data);
	}

	/**
	 * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.
	 */
	function mintBatch(
		address to,
		uint256[] memory ids,
		uint256[] memory amounts,
		bytes memory data
	) internal virtual {
		require(hasRole(MINTER_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have minter role to mint");

		_mintBatch(to, ids, amounts, data);
	}

	/**
	 * @dev Pauses all token transfers.
	 *
	 * See {ERC1155Pausable} and {Pausable-_pause}.
	 *
	 * Requirements:
	 *
	 * - the caller must have the `PAUSER_ROLE`.
	 */
	function pause() public virtual {
		require(hasRole(PAUSER_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have pauser role to pause");
		_pause();
	}

	/**
	 * @dev Unpauses all token transfers.
	 *
	 * See {ERC1155Pausable} and {Pausable-_unpause}.
	 *
	 * Requirements:
	 *
	 * - the caller must have the `PAUSER_ROLE`.
	 */
	function unpause() public virtual {
		require(hasRole(PAUSER_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have pauser role to unpause");
		_unpause();
	}

	/**
	 * @dev See {IERC165-supportsInterface}.
	 */
	function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControlEnumerableUpgradeable, ERC1155Upgradeable) returns (bool) {
		return super.supportsInterface(interfaceId);
	}

	function _beforeTokenTransfer(
		address operator,
		address from,
		address to,
		uint256[] memory ids,
		uint256[] memory amounts,
		bytes memory data
	) internal virtual override(ERC1155Upgradeable, ERC1155PausableUpgradeable) {
		super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
	}

	uint256[50] private __gap;
}
